{% extends "base.html" %}

{% block title %}Singapore Traffic Analysis Dashboard{% endblock %}

{% block extra_css %}
<!-- Chart.js -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.css">
<!-- DateRangePicker -->
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />
<!-- Leaflet for maps -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
<!-- Custom CSS -->
<style>
.metric-card {
    padding: 1rem;
    border-radius: 0.5rem;
    background: #fff;
    box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,0.075);
    margin-bottom: 1rem;
}
.trend-up { color: #28a745; }
.trend-down { color: #dc3545; }
.chart-container { position: relative; height: 300px; width: 100%; }
#location-map { height: 400px; border-radius: 0.5rem; }
.severity-high { color: #dc3545; }
.severity-medium { color: #ffc107; }
.severity-low { color: #28a745; }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h1>Singapore Traffic Analysis Dashboard</h1>
        <div class="btn-group">
            <button id="refresh-data" class="btn btn-outline-primary">
                <i class="fas fa-sync-alt"></i> Refresh Data
            </button>
            <button id="export-data" class="btn btn-outline-success">
                <i class="fas fa-download"></i> Export Report
            </button>
        </div>
    </div>

    <!-- Analysis Controls -->
    <div class="card mb-4">
        <div class="card-body">
            <div class="row g-3">
                <div class="col-md-12">
                    <label for="dataset-select" class="form-label">Analysis Dataset</label>
                    <select id="dataset-select" class="form-select">
                        <option value="">Select dataset...</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <!-- Summary Metrics -->
    <div class="row mb-4">
        <div class="col-md-3">
            <div class="metric-card">
                <h6><i class="fas fa-map-marker-alt"></i> Total Locations</h6>
                <div class="d-flex justify-content-between align-items-center">
                    <h3 id="total-locations">-</h3>
                    <span id="location-trend" class="trend"></span>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="metric-card">
                <h6><i class="fas fa-car-crash"></i> Traffic Incidents</h6>
                <div class="d-flex justify-content-between align-items-center">
                    <h3 id="total-incidents">-</h3>
                    <span id="incident-trend" class="trend"></span>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="metric-card">
                <h6><i class="fas fa-smile"></i> Sentiment Score</h6>
                <div class="d-flex justify-content-between align-items-center">
                    <h3 id="sentiment-score">-</h3>
                    <span id="sentiment-trend" class="trend"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Risk Assessment Section -->
    <div class="row mb-4">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header bg-danger text-white">
                    <h5 class="mb-0"><i class="fas fa-exclamation-triangle"></i> Traffic Risk Assessment</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4">
                            <div class="d-flex align-items-center mb-3">
                                <div style="width: 60px; height: 60px;" class="rounded-circle bg-danger d-flex align-items-center justify-content-center me-3">
                                    <h3 class="text-white mb-0" id="high-risk-count">-</h3>
                                </div>
                                <div>
                                    <h5 class="mb-0">High Risk Areas</h5>
                                    <p class="text-muted mb-0"><small>Immediate caution advised</small></p>
                                </div>
                            </div>
                            <ul class="list-group" id="high-risk-areas">
                                <li class="list-group-item text-danger">Loading areas...</li>
                            </ul>
                        </div>
                        <div class="col-md-4">
                            <div class="d-flex align-items-center mb-3">
                                <div style="width: 60px; height: 60px;" class="rounded-circle bg-warning d-flex align-items-center justify-content-center me-3">
                                    <h3 class="text-white mb-0" id="medium-risk-count">-</h3>
                                </div>
                                <div>
                                    <h5 class="mb-0">Medium Risk Areas</h5>
                                    <p class="text-muted mb-0"><small>Increased awareness needed</small></p>
                                </div>
                            </div>
                            <ul class="list-group" id="medium-risk-areas">
                                <li class="list-group-item text-warning">Loading areas...</li>
                            </ul>
                        </div>
                        <div class="col-md-4">
                            <div class="d-flex align-items-center mb-3">
                                <div style="width: 60px; height: 60px;" class="rounded-circle bg-success d-flex align-items-center justify-content-center me-3">
                                    <h3 class="text-white mb-0" id="safety-tips-count">3</h3>
                                </div>
                                <div>
                                    <h5 class="mb-0">Driver Safety Tips</h5>
                                    <p class="text-muted mb-0"><small>Based on current data</small></p>
                                </div>
                            </div>
                            <ul class="list-group" id="safety-tips">
                                <li class="list-group-item"><i class="fas fa-check-circle text-success me-2"></i> Slow down in high-risk areas</li>
                                <li class="list-group-item"><i class="fas fa-check-circle text-success me-2"></i> Increase following distance during peak hours</li>
                                <li class="list-group-item"><i class="fas fa-check-circle text-success me-2"></i> Stay alert at intersections</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Traffic Patterns Section -->
    <div class="row mb-4">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header bg-warning text-dark">
                    <h5 class="mb-0"><i class="far fa-clock"></i> Traffic Patterns</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-12">
                            <h5>Daily Traffic Pattern</h5>
                            <canvas id="time-pattern-chart" height="250"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Analysis Section -->
    <div class="row">
        <!-- Map View -->
        <div class="col-md-8">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="mb-0"><i class="fas fa-map-marked-alt"></i> Traffic Incident Map</h5>
                </div>
                <div class="card-body">
                    <div id="location-map"></div>
                </div>
            </div>
        </div>

        <!-- Sentiment Analysis -->
        <div class="col-md-4">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="mb-0"><i class="fas fa-heart"></i> Public Sentiment</h5>
                </div>
                <div class="card-body">
                    <canvas id="sentiment-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <!-- Brand Analysis -->
        <div class="col-md-12">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="mb-0"><i class="fas fa-car"></i> Vehicle Brand Analysis</h5>
                </div>
                <div class="card-body">
                    <canvas id="brands-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Adding a new chart for Vehicle Models -->
    <div class="row mb-4">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0"><i class="fas fa-car-side"></i> Vehicle Model Analysis</h5>
                </div>
                <div class="card-body">
                    <canvas id="models-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Reddit Sentiment Analysis Section -->
    <div class="row mb-4">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0"><i class="fab fa-reddit-alien"></i> Reddit Sentiment Analysis</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4">
                            <h5>Sentiment Overview</h5>
                            <div id="reddit-sentiment-overview" class="py-3">
                                <div class="d-flex justify-content-between mb-2">
                                    <span>Positive</span>
                                    <span id="positive-percentage">-</span>
                                </div>
                                <div class="progress mb-3" style="height: 25px;">
                                    <div id="positive-bar" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                                </div>
                                
                                <div class="d-flex justify-content-between mb-2">
                                    <span>Neutral</span>
                                    <span id="neutral-percentage">-</span>
                                </div>
                                <div class="progress mb-3" style="height: 25px;">
                                    <div id="neutral-bar" class="progress-bar bg-secondary" role="progressbar" style="width: 0%"></div>
                                </div>
                                
                                <div class="d-flex justify-content-between mb-2">
                                    <span>Negative</span>
                                    <span id="negative-percentage">-</span>
                                </div>
                                <div class="progress mb-3" style="height: 25px;">
                                    <div id="negative-bar" class="progress-bar bg-danger" role="progressbar" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <h5>Key Topics</h5>
                            <div class="list-group" id="sentiment-topics">
                                <div class="list-group-item">
                                    <div class="d-flex w-100 justify-content-between">
                                        <h6 class="mb-1">Loading topics...</h6>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <h5>Driver Insights</h5>
                            <div class="card bg-light">
                                <div class="card-body" id="sentiment-insights">
                                    <p>Analyzing sentiment data to generate driver insights...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div id="loading-overlay" style="display: none;">
    <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Required Libraries -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

<!-- Custom JS -->
<script>
// Initialize map
const map = L.map('location-map').setView([1.3521, 103.8198], 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors'
}).addTo(map);

// Initialize charts
const sentimentChart = new Chart(document.getElementById('sentiment-chart'), {
    type: 'doughnut',
    data: {
        labels: ['Positive', 'Neutral', 'Negative'],
        datasets: [{
            data: [0, 0, 0],
            backgroundColor: ['#28a745', '#6c757d', '#dc3545']
        }]
    },
    options: {
        responsive: true,
        plugins: {
            legend: {
                position: 'bottom'
            }
        }
    }
});

const brandsChart = new Chart(document.getElementById('brands-chart'), {
    type: 'bar',
    data: {
        labels: [],
        datasets: [{
            label: 'Mentions',
            data: [],
            backgroundColor: '#007bff'
        }]
    },
    options: {
        responsive: true,
        plugins: {
            legend: {
                display: false
            }
        },
        scales: {
            y: {
                beginAtZero: true
            }
        }
    }
});

// Initialize models chart
const modelsChart = new Chart(document.getElementById('models-chart'), {
    type: 'bar',
    data: {
        labels: [],
        datasets: [{
            label: 'Vehicle Models',
            data: [],
            backgroundColor: '#28a745'
        }]
    },
    options: {
        responsive: true,
        plugins: {
            legend: {
                display: false
            },
            title: {
                display: true,
                text: 'Popular Vehicle Models'
            }
        },
        scales: {
            y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'Mentions'
                }
            },
            x: {
                title: {
                    display: true,
                    text: 'Vehicle Model'
                }
            }
        }
    }
});

// Initialize traffic pattern chart
const timePatternChart = new Chart(document.getElementById('time-pattern-chart'), {
    type: 'line',
    data: {
        labels: ['6 AM', '7 AM', '8 AM', '9 AM', '10 AM', '11 AM', '12 PM', '1 PM', '2 PM', '3 PM', '4 PM', '5 PM', '6 PM', '7 PM', '8 PM', '9 PM', '10 PM', '11 PM'],
        datasets: [{
            label: 'Traffic Incidents',
            data: [10, 25, 65, 42, 30, 25, 35, 30, 28, 30, 35, 55, 70, 45, 30, 25, 15, 10],
            borderColor: '#ff6b6b',
            backgroundColor: 'rgba(255, 107, 107, 0.1)',
            tension: 0.3,
            fill: true
        }]
    },
    options: {
        responsive: true,
        plugins: {
            legend: {
                position: 'top',
            },
            tooltip: {
                callbacks: {
                    label: function(context) {
                        return `Incidents: ${context.raw}`;
                    }
                }
            }
        },
        scales: {
            y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'Incident Count'
                }
            },
            x: {
                title: {
                    display: true,
                    text: 'Time of Day'
                }
            }
        }
    }
});

// Load and update data
async function loadData(analysisId) {
    try {
        // Show loading indicator
        document.getElementById('refresh-data').disabled = true;
        document.getElementById('refresh-data').innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
        
        // Get all selected analyses for the dataset
        const selectedDataset = analysisId.split('|')[0];
        const selectedRunDate = analysisId.split('|')[1];
        
        // Load all analyses for this dataset
        const analyses = await loadAllAnalysesForDataset(selectedDataset, selectedRunDate);
        
        // Always use 'all' as the analysis type since we removed the selector
        const selectedAnalysisType = 'all';
        
        updateDashboard(analyses, selectedAnalysisType);
    } catch (error) {
        console.error('Error loading analysis data:', error);
        alert(`Error loading data: ${error.message}`);
    } finally {
        // Hide loading indicator
        document.getElementById('refresh-data').disabled = false;
        document.getElementById('refresh-data').innerHTML = '<i class="fas fa-sync-alt"></i> Refresh Data';
    }
}

async function loadAllAnalysesForDataset(dataset, runDate) {
    // This function will load all analysis types for a dataset+runDate combination
    const analyses = {};
    
    // Try multiple possible paths for the index file
    const possibleIndexPaths = [
        '/static/data/analyses_index.json',
        '../static/data/analyses_index.json',
        './static/data/analyses_index.json',
        '../../../data/web/visualizations/data/analyses_index.json'
    ];
    
    let indexData = null;
    
    // Try each path until we find the index file
    for (const path of possibleIndexPaths) {
        try {
            console.log('Trying to load index from:', path);
            const response = await fetch(path);
            if (response.ok) {
                indexData = await response.json();
                console.log('Successfully loaded index from:', path);
                break;
            }
        } catch (error) {
            console.warn(`Failed to load index from ${path}:`, error);
        }
    }
    
    if (!indexData) {
        throw new Error('Could not find analyses index file');
    }
    
    // Find all analyses that match our dataset and run date
    const matchingAnalyses = indexData.analyses.filter(a => 
        a.dataset === dataset && a.run_date === runDate
    );
    
    console.log('Found matching analyses:', matchingAnalyses);
    
    // For each matching analysis, load the summary file directly using the path in the index
    for (const analysis of matchingAnalyses) {
        try {
            console.log(`Loading ${analysis.analysis_type} from: ${analysis.summary_file}`);
            const response = await fetch(analysis.summary_file);
            
            if (response.ok) {
    const data = await response.json();
                
                // Process raw data if it's in the MapReduce output format
                if (data.summary_file && data.output_dir && !data.data) {
                    console.log(`Summary file format detected for ${analysis.analysis_type}, loading raw data...`);
                    const rawDataResponse = await fetchRawAnalysisData(analysis.analysis_type, data.output_dir);
                    if (rawDataResponse) {
                        // Process the raw data into a standardized format
                        const processedData = processRawAnalysisData(rawDataResponse, analysis.analysis_type);
                        // Add the processed data to the summary
                        data.data = processedData;
                        console.log(`Processed raw data for ${analysis.analysis_type}:`, processedData.slice(0, 5));
                    }
                }
                
                analyses[analysis.analysis_type] = data;
                console.log(`Successfully loaded ${analysis.analysis_type} from: ${analysis.summary_file}`);
                
                // If this is location data, parse coordinates and prepare for map
                if (analysis.analysis_type === 'location' && data.data) {
                    analyses[analysis.analysis_type].locations = data.data.map(item => {
                        const name = item.key.replace('location:', '');
                        return {
                            name: name,
                            count: item.value,
                            coordinates: getCoordinates(name)
                        };
                    });
                }
            } else {
                console.error(`Error loading ${analysis.analysis_type} from ${analysis.summary_file}: ${response.status} ${response.statusText}`);
            }
        } catch (error) {
            console.error(`Failed to load ${analysis.analysis_type} from ${analysis.summary_file}:`, error);
        }
    }
    
    // Get the analysis types that were actually loaded
    const loadedAnalysisTypes = Object.keys(analyses);
    console.log('Loaded analysis types:', loadedAnalysisTypes);
    
    return {
        dataset_id: `${dataset}_${runDate}`,
        ...analyses
    };
}

// Helper function to fetch raw analysis data from MapReduce output
async function fetchRawAnalysisData(analysisType, outputDir) {
    // Try to parse the output directory to construct a path to the part-r-00000 file
    try {
        // Convert relative path to absolute if needed
        const basePath = outputDir.startsWith('/') ? '' : '../';
        const rawDataPath = `${basePath}${outputDir}/part-r-00000`;
        
        console.log(`Attempting to fetch raw data from: ${rawDataPath}`);
        const response = await fetch(rawDataPath);
        
        if (response.ok) {
            const text = await response.text();
            console.log(`Successfully loaded raw data for ${analysisType}`);
            return text;
        } else {
            console.error(`Failed to load raw data from ${rawDataPath}: ${response.status} ${response.statusText}`);
            return null;
        }
    } catch (error) {
        console.error(`Error fetching raw analysis data: ${error}`);
        return null;
    }
}

// Helper function to process raw analysis data from MapReduce output
function processRawAnalysisData(rawData, analysisType) {
    try {
        // Split the raw data into lines
        const lines = rawData.trim().split('\n');
        
        // Process each line into key-value pairs
        const processedData = lines.map(line => {
            const [key, valueStr] = line.split('\t');
            const value = parseInt(valueStr, 10);
            
            return {
                key: key,
                value: isNaN(value) ? 0 : value
            };
        });
        
        // For brand analysis, perform special processing to clean up duplicates and properly classify brands/models
        if (analysisType === 'brands') {
            return processBrandData(processedData);
        }
        
        // Filter out any potentially problematic entries
        return processedData.filter(item => 
            item.key && 
            item.key.trim() !== '' && 
            !isNaN(item.value)
        );
        
    } catch (error) {
        console.error(`Error processing raw analysis data: ${error}`);
        return [];
    }
}

// Special processing for brand data to clean up duplicates and properly classify
function processBrandData(rawData) {
    console.log('Processing brand data, initial count:', rawData.length);
    const processedData = [];
    const brandMap = new Map();
    const modelMap = new Map();
    let seenBrands = new Set(); // Track seen brands to avoid duplicates
    let seenModels = new Set(); // Track seen models to avoid duplicates
    
    // Define known car brands for classification
    const carBrands = new Set([
        'toyota', 'honda', 'nissan', 'mazda', 'mitsubishi', 'subaru', 'lexus', 'acura', 'infiniti', 
        'ford', 'chevrolet', 'gmc', 'cadillac', 'chrysler', 'dodge', 'jeep', 'ram', 'buick', 
        'volkswagen', 'audi', 'bmw', 'mercedes', 'porsche', 'mini', 'volvo', 'saab', 'jaguar', 'land rover',
        'ferrari', 'lamborghini', 'maserati', 'alfa romeo', 'fiat', 'peugeot', 'renault', 'citroen',
        'hyundai', 'kia', 'genesis', 'daewoo', 'proton', 'perodua', 'tata', 'mahindra', 'tesla'
    ]);
    
    // Define known models for brands to help with classification
    const brandModels = {
        'toyota': ['corolla', 'camry', 'rav4', 'prius', 'highlander', 'tacoma', 'tundra', 'sienna', 'vios', 'yaris', 'altis'],
        'honda': ['civic', 'accord', 'cr-v', 'pilot', 'fit', 'jazz', 'vezel', 'freed', 'hrv', 'city'],
        'nissan': ['altima', 'maxima', 'sentra', 'rogue', 'murano', 'pathfinder', 'leaf', 'juke', 'qashqai'],
        'mazda': ['mazda3', 'mazda6', 'cx-5', 'cx-9', 'miata', 'mx-5'],
        'bmw': ['325i', '330i', '530i', '740i', 'x3', 'x5', 'z4', 'i3', 'i8'],
        'audi': ['a3', 'a4', 'a6', 'a8', 'q3', 'q5', 'q7', 'tt', 'r8'],
        'mercedes': ['c-class', 'e-class', 's-class', 'cla', 'gla', 'gle', 'glc'],
        'hyundai': ['elantra', 'sonata', 'tucson', 'santa fe', 'kona', 'ioniq'],
        'kia': ['forte', 'optima', 'soul', 'sportage', 'sorento', 'stinger'],
        'ford': ['focus', 'fusion', 'escape', 'explorer', 'edge', 'mustang', 'f-150'],
        'mitsubishi': ['lancer', 'outlander', 'eclipse', 'mirage', 'pajero'],
        'proton': ['saga', 'perdana', 'exora', 'iriz', 'persona'],
        'perodua': ['myvi', 'alza', 'axia', 'bezza', 'aruz']
    };
    
    // Flatten the model list for quick lookups
    const allKnownModels = new Set();
    Object.values(brandModels).forEach(models => {
        models.forEach(model => allKnownModels.add(model.toLowerCase()));
    });
    
    // First pass: process the raw data
    rawData.forEach(item => {
        // Extract the value, removing any prefix like "brand:" or "total:"
        const keyParts = item.key.split(':');
        const prefix = keyParts[0]; // This could be 'brand', 'brand_comment', 'total', etc.
        let value = keyParts.length > 1 ? keyParts[1].trim() : item.key.trim();
        
        // Skip empty values
        if (!value) return;
        
        // Normalize value to lowercase for comparison
        const normalizedValue = value.toLowerCase();
        
        // Skip if this is just a counting prefix and not useful data
        if (['count', 'total', 'sum', 'number'].includes(normalizedValue)) return;
        
        // First, check if it's explicitly labeled
        if (prefix === 'model' || prefix === 'model_comment') {
            // It's explicitly a model - create a standardized format entry
            processedData.push({
                key: `model:${normalizedValue}`,
                value: item.value
            });
            
            // Track for deduplication
            if (!seenModels.has(normalizedValue)) {
                modelMap.set(normalizedValue, (modelMap.get(normalizedValue) || 0) + item.value);
                seenModels.add(normalizedValue);
            }
        } else if (prefix === 'brand' || prefix === 'brand_comment') {
            // It's explicitly a brand - create a standardized format entry
            processedData.push({
                key: `brand:${normalizedValue}`,
                value: item.value
            });
            
            // Track for deduplication
            if (!seenBrands.has(normalizedValue)) {
                brandMap.set(normalizedValue, (brandMap.get(normalizedValue) || 0) + item.value);
                seenBrands.add(normalizedValue);
            }
        } else {
            // Not explicitly labeled, so we need to classify
            // First check if it's a known brand
            if (carBrands.has(normalizedValue)) {
                processedData.push({
                    key: `brand:${normalizedValue}`,
                    value: item.value
                });
                
                if (!seenBrands.has(normalizedValue)) {
                    brandMap.set(normalizedValue, (brandMap.get(normalizedValue) || 0) + item.value);
                    seenBrands.add(normalizedValue);
                }
            } 
            // Then check if it's a known model
            else if (allKnownModels.has(normalizedValue)) {
                processedData.push({
                    key: `model:${normalizedValue}`,
                    value: item.value
                });
                
                if (!seenModels.has(normalizedValue)) {
                    modelMap.set(normalizedValue, (modelMap.get(normalizedValue) || 0) + item.value);
                    seenModels.add(normalizedValue);
                }
            }
            // If we still can't tell, use heuristics
            else {
                // If it contains spaces or hyphens, it's more likely to be a model
                if (normalizedValue.includes(' ') || normalizedValue.includes('-') || /[0-9]/.test(normalizedValue)) {
                    processedData.push({
                        key: `model:${normalizedValue}`,
                        value: item.value
                    });
                    
                    if (!seenModels.has(normalizedValue)) {
                        modelMap.set(normalizedValue, (modelMap.get(normalizedValue) || 0) + item.value);
                        seenModels.add(normalizedValue);
                    }
                }
                // Otherwise assume it's a brand
                else {
                    processedData.push({
                        key: `brand:${normalizedValue}`,
                        value: item.value
                    });
                    
                    if (!seenBrands.has(normalizedValue)) {
                        brandMap.set(normalizedValue, (brandMap.get(normalizedValue) || 0) + item.value);
                        seenBrands.add(normalizedValue);
                    }
                }
            }
        }
    });
    
    // Second pass: add deduplicated brand/model aggregates
    brandMap.forEach((count, brand) => {
        processedData.push({
            key: `brand_total:${brand}`,
            value: count
        });
    });
    
    modelMap.forEach((count, model) => {
        processedData.push({
            key: `model_total:${model}`,
            value: count
        });
    });
    
    console.log(`Processed brand data: ${processedData.length} entries, ${brandMap.size} unique brands, ${modelMap.size} unique models`);
    
    return processedData;
}

function updateDashboard(data, selectedAnalysisType) {
    console.log('Updating dashboard with data:', data);
    console.log('Selected analysis type:', selectedAnalysisType);
    
    // If a specific analysis type is selected, only show that data
    const shouldFilterByType = selectedAnalysisType !== 'all';
    
    // Update summary metrics
    if (data.location && (!shouldFilterByType || selectedAnalysisType === 'location')) {
        // Try to get total incidents from different possible formats
        let totalIncidents = 0;
        if (data.location.total_incidents) {
            totalIncidents = data.location.total_incidents;
        } else if (data.location.data) {
            // Sum the values from the data array
            totalIncidents = data.location.data.reduce((sum, item) => sum + item.value, 0);
        }
        document.getElementById('total-locations').textContent = totalIncidents || 0;
    
    // Update map
    map.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
            map.removeLayer(layer);
        }
    });
    
        // Handle different location data structures
        let locationData = [];
        if (data.location.locations) {
            locationData = data.location.locations;
        } else if (data.location.data) {
            // Convert from summary.json format to locations array
            locationData = data.location.data.map(item => {
                const name = item.key.replace('location:', '');
                return {
                    name: name,
                    count: item.value,
                    coordinates: getCoordinates(name)
                };
            });
        }
        
        // Create markers for each location with custom icons based on risk level
        locationData.forEach(loc => {
            const coords = loc.coordinates || getCoordinates(loc.name);
            if (coords) {
                // Determine risk level based on incident count
                const riskLevel = getRiskLevel(loc.count);
                const markerColor = riskLevel === 'high' ? 'red' : 
                                    riskLevel === 'medium' ? 'orange' : 'green';
                
                // Create custom icon based on risk level
                const customIcon = L.divIcon({
                    className: 'custom-marker',
                    html: `<div style="background-color: ${markerColor}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white;"></div>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });
                
                const marker = L.marker([coords.lat, coords.lng], { icon: customIcon })
            .bindPopup(`
                <strong>${loc.name}</strong><br>
                Incidents: ${loc.count}<br>
                    Risk Level: <span class="text-${riskLevel === 'high' ? 'danger' : riskLevel === 'medium' ? 'warning' : 'success'}">${riskLevel.toUpperCase()}</span><br>
                    ${coords.description || ''}
            `)
            .addTo(map);
            }
        });
        
        // Update risk assessment section
        updateRiskAssessment(locationData);
    } else if (shouldFilterByType && selectedAnalysisType === 'location') {
        // If location analysis was selected but not available
        document.getElementById('total-locations').textContent = 'N/A';
        // Clear the map
        map.eachLayer((layer) => {
            if (layer instanceof L.Marker) {
                map.removeLayer(layer);
            }
        });
    }
    
    // Update traffic incidents count
    if (data.traffic && (!shouldFilterByType || selectedAnalysisType === 'traffic')) {
        let totalIncidents = 0;
        if (data.traffic.summary && data.traffic.summary.total) {
            totalIncidents = data.traffic.summary.total;
        } else if (data.traffic.data) {
            totalIncidents = data.traffic.data.reduce((sum, item) => sum + item.value, 0);
        }
        document.getElementById('total-incidents').textContent = totalIncidents || 0;
    } else if (shouldFilterByType && selectedAnalysisType === 'traffic') {
        document.getElementById('total-incidents').textContent = 'N/A';
    }

    // Update sentiment chart
    if (data.sentiment && (!shouldFilterByType || selectedAnalysisType === 'sentiment')) {
        let sentimentData = [];
        if (data.sentiment.sentiments) {
            sentimentData = data.sentiment.sentiments;
        } else if (data.sentiment.data) {
            // Convert from summary.json format
            const total = data.sentiment.data.reduce((sum, item) => sum + item.value, 0);
            sentimentData = data.sentiment.data.map(item => {
                const sentiment = item.key.replace('sentiment:', '');
                return {
                    sentiment: sentiment,
                    count: item.value,
                    percentage: Math.round((item.value / total) * 100 * 10) / 10,
                    color: sentiment === 'positive' ? '#28a745' : 
                           sentiment === 'negative' ? '#dc3545' : '#6c757d'
                };
            });
        }
        
    sentimentChart.data.datasets[0].data = [
            sentimentData.find(s => s.sentiment === 'positive')?.count || 0,
            sentimentData.find(s => s.sentiment === 'neutral')?.count || 0,
            sentimentData.find(s => s.sentiment === 'negative')?.count || 0
    ];
    sentimentChart.update();
        
        // Update sentiment score in summary
        const positivePercentage = sentimentData.find(s => s.sentiment === 'positive')?.percentage || 0;
        document.getElementById('sentiment-score').textContent = positivePercentage.toFixed(1) + '%';
        
        // Update Reddit sentiment analysis section
        updateRedditSentimentAnalysis(sentimentData, data);
    } else if (shouldFilterByType && selectedAnalysisType === 'sentiment') {
        // Reset sentiment chart if sentiment analysis was selected but not available
        sentimentChart.data.datasets[0].data = [0, 0, 0];
        sentimentChart.update();
        document.getElementById('sentiment-score').textContent = 'N/A';
        
        // Reset Reddit sentiment section
        resetRedditSentimentSection();
    }

    // Update brands and models charts
    if (selectedAnalysisType === 'all' || selectedAnalysisType === 'brands') {
        if (data.brands) {
            let brandData = [];
            let modelData = [];
            
            if (data.brands.brands) {
                brandData = data.brands.brands;
                modelData = data.brands.models || [];
            } else if (data.brands.data) {
                // Process data in the format from raw files
                const brandMap = new Map();
                const modelMap = new Map(); 
                
                data.brands.data.forEach(item => {
                    const keyParts = item.key.split(':');
                    const type = keyParts[0];
                    const value = keyParts.length > 1 ? keyParts[1].trim() : item.key.trim();
                    
                    // Skip empty values
                    if (!value) return;
                    
                    if (type === 'brand_total') {
                        brandMap.set(value, item.value);
                    } else if (type === 'model_total') {
                        modelMap.set(value, item.value);
                    } else if (type === 'brand') {
                        // Only use individual brand entries if we don't have totals
                        if (!brandMap.has(value)) {
                            brandMap.set(value, item.value);
                        }
                    } else if (type === 'model') {
                        // Only use individual model entries if we don't have totals
                        if (!modelMap.has(value)) {
                            modelMap.set(value, item.value);
                        }
                    }
                });
                
                // Convert maps to arrays of objects
                brandData = Array.from(brandMap.entries()).map(([brand, total]) => ({ brand, total }));
                modelData = Array.from(modelMap.entries()).map(([model, total]) => ({ model, total }));
                
                // Sort by count (highest first)
                brandData.sort((a, b) => b.total - a.total);
                modelData.sort((a, b) => b.total - a.total);
            }
            
            // Update the brands chart
            const brands = brandData.slice(0, 10);
            brandsChart.data.labels = brands.map(b => b.brand.charAt(0).toUpperCase() + b.brand.slice(1)); // Capitalize first letter
    brandsChart.data.datasets[0].data = brands.map(b => b.total);
    brandsChart.update();
            
            // Update the models chart
            const models = modelData.slice(0, 10);
            modelsChart.data.labels = models.map(m => m.model.charAt(0).toUpperCase() + m.model.slice(1)); // Capitalize first letter
            modelsChart.data.datasets[0].data = models.map(m => m.total);
            modelsChart.update();
            
            // If we have no model data, but we have brand data, try to extract models from known brands
            if (models.length === 0 && brands.length > 0) {
                console.log('No model data found, attempting to extract from known brand models...');
                const extractedModels = extractModelsForTopBrands(brands);
                if (extractedModels.length > 0) {
                    modelsChart.data.labels = extractedModels.map(m => m.model.charAt(0).toUpperCase() + m.model.slice(1));
                    modelsChart.data.datasets[0].data = extractedModels.map(m => m.total);
                    modelsChart.update();
                }
            }
        } else if (shouldFilterByType && selectedAnalysisType === 'brands') {
            // Reset brands and models charts if brand analysis was selected but not available
            brandsChart.data.labels = [];
            brandsChart.data.datasets[0].data = [];
            brandsChart.update();
            
            modelsChart.data.labels = [];
            modelsChart.data.datasets[0].data = [];
            modelsChart.update();
            
            console.warn('Brand analysis selected but not available in the loaded data');
            alert('Brand analysis is not available for the selected dataset');
        }
    }

    // Update traffic patterns
    updateTrafficPatternChart();
}

// Helper function to get coordinates for a location
function getCoordinates(location) {
    const locationMap = {
        // Updated with more accurate coordinates for Singapore expressways and areas
        'cte': { lat: 1.3354, lng: 103.8501, description: 'Central Expressway' },
        'changi': { lat: 1.3644, lng: 103.9915, description: 'Changi Area' },
        'sle': { lat: 1.4023, lng: 103.8254, description: 'Seletar Expressway' },
        'pie': { lat: 1.3401, lng: 103.8001, description: 'Pan Island Expressway' },
        'aye': { lat: 1.2950, lng: 103.7834, description: 'Ayer Rajah Expressway' },
        'woodlands': { lat: 1.4382, lng: 103.7891, description: 'Woodlands Area' },
        'tampines': { lat: 1.3496, lng: 103.9568, description: 'Tampines Area' },
        'amk': { lat: 1.3691, lng: 103.8454, description: 'Ang Mo Kio Area' },
        'tpe': { lat: 1.3822, lng: 103.9207, description: 'Tampines Expressway' },
        'bke': { lat: 1.3945, lng: 103.7733, description: 'Bukit Timah Expressway' },
        'kje': { lat: 1.3793, lng: 103.7445, description: 'Kranji Expressway' },
        'ecp': { lat: 1.2979, lng: 103.8757, description: 'East Coast Parkway' },
        'yishun': { lat: 1.4304, lng: 103.8354, description: 'Yishun Area' },
        'jurong': { lat: 1.3329, lng: 103.7436, description: 'Jurong Area' },
        'pasir_ris': { lat: 1.3721, lng: 103.9474, description: 'Pasir Ris Area' },
        'sengkang': { lat: 1.3868, lng: 103.8914, description: 'Sengkang Area' },
        'punggol': { lat: 1.4041, lng: 103.9087, description: 'Punggol Area' },
        'bedok': { lat: 1.3236, lng: 103.9273, description: 'Bedok Area' },
        'clementi': { lat: 1.3162, lng: 103.7649, description: 'Clementi Area' },
        'orchard': { lat: 1.3036, lng: 103.8318, description: 'Orchard Road Area' },
        'cbd': { lat: 1.2789, lng: 103.8536, description: 'Central Business District' }
    };
    
    // Normalize the location string to handle different formats
    const normalizedLocation = location.toLowerCase().trim();
    
    // First try exact match
    if (locationMap[normalizedLocation]) {
        return locationMap[normalizedLocation];
    }
    
    // Then try partial match (in case location includes additional text)
    for (const [key, value] of Object.entries(locationMap)) {
        if (normalizedLocation.includes(key)) {
            return value;
        }
    }
    
    // Default to central Singapore if no match is found
    console.warn(`No coordinates found for location: ${location}`);
    return { lat: 1.3521, lng: 103.8198, description: 'Singapore (Location not precisely mapped)' };
}

// Helper function to format date from dataset ID
function formatDate(dateString) {
    // Handle various date formats 
    if (dateString && dateString.includes('_')) {
        const parts = dateString.split('_');
        if (parts.length >= 2) {
            // Format: YYYYMMDD_HHMMSS
            const date = parts[0];
            const time = parts[1];
            
            if (date.length >= 8 && time && time.length >= 6) {
                return `${date.substring(0,4)}-${date.substring(4,6)}-${date.substring(6,8)} ${time.substring(0,2)}:${time.substring(2,4)}`;
            } else if (date.length >= 8) {
                return `${date.substring(0,4)}-${date.substring(4,6)}-${date.substring(6,8)}`;
            }
        }
    } else if (dateString && dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
        // Already in YYYY-MM-DD format
        return dateString;
    }
    return dateString || '';
}

// Load available datasets with better date range filtering
async function loadDatasets() {
    try {
        // Try multiple possible paths for the index file in Flask context
        const possiblePaths = [
            '/static/data/analyses_index.json',
            '../static/data/analyses_index.json',
            './static/data/analyses_index.json',
            '../../../data/web/visualizations/data/analyses_index.json'
        ];
        
        let response;
        let data;
        let successfulPath = '';
        
        // Try each path until one works
        for (const path of possiblePaths) {
            try {
                console.log('Attempting to load from:', path);
                response = await fetch(path);
                if (response.ok) {
                    data = await response.json();
                    successfulPath = path;
                    console.log('Successfully loaded from:', path);
                    break;
                }
            } catch (e) {
                console.warn(`Failed to load from ${path}:`, e);
            }
        }
        
        if (!data) {
            throw new Error(`Failed to load datasets index from any of the attempted paths`);
        }
        
        console.log('Using datasets from:', successfulPath);
        const analyses = data.analyses || [];
        const select = document.getElementById('dataset-select');
        select.innerHTML = '<option value="">Select dataset...</option>';
        
        // Group analyses by dataset and run date
        const datasetGroups = {};
        analyses.forEach(analysis => {
            const key = `${analysis.dataset}|${analysis.run_date}`;
            if (!datasetGroups[key]) {
                datasetGroups[key] = {
                    id: key,
                    dataset: analysis.dataset,
                    data_date: analysis.data_date || '',
                    run_date: analysis.run_date,
                    analysisTypes: [],
                    timestamp: analysis.data_date ? new Date(formatDate(analysis.data_date)).getTime() : 0
                };
            }
            
            // Add this analysis type to the group
            if (!datasetGroups[key].analysisTypes.includes(analysis.analysis_type)) {
                datasetGroups[key].analysisTypes.push(analysis.analysis_type);
            }
        });
        
        // Sort datasets by timestamp (newest first)
        const sortedDatasets = Object.values(datasetGroups).sort((a, b) => b.timestamp - a.timestamp);
        
        // Add options to the dropdown - filter out any datasets that only have 'trend' analysis
        sortedDatasets.forEach(group => {
            // Filter out 'trend' from the analysis types
            const filteredTypes = group.analysisTypes.filter(type => type.toLowerCase() !== 'trend');
            
            // Skip datasets that only had 'trend' analysis (would now have empty filteredTypes)
            if (filteredTypes.length === 0) return;
            
            const analysisTypes = filteredTypes.map(type => type.charAt(0).toUpperCase() + type.slice(1)).join(', ');
            
            const displayDate = formatDate(group.run_date);
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = `${group.dataset} (${analysisTypes}) - ${displayDate}`;
            option.dataset.types = filteredTypes.join(',');
            select.appendChild(option);
        });
        
        // Load the first dataset if available
        if (sortedDatasets.length > 0) {
            const firstGroup = sortedDatasets[0];
            select.value = firstGroup.id;
            loadData(firstGroup.id);
        }
    } catch (error) {
        console.error('Error loading datasets:', error);
        alert('Failed to load datasets index. Please check the console for more details.');
    }
}

// Function to setup the date range picker based on available data
function setupDateRangePicker(datasets) {
    // Extract all dates from datasets for better filtering
    const allDates = [];
    
    datasets.forEach(dataset => {
        if (dataset.data_date) {
            try {
                // Try to parse the date
                const date = new Date(formatDate(dataset.data_date));
                if (!isNaN(date.getTime())) {
                    allDates.push({
                        date: date,
                        timestamp: date.getTime(),
                        datasetId: dataset.id
                    });
                }
            } catch (e) {
                console.warn('Error parsing date:', dataset.data_date, e);
            }
        }
        
        // Also try to parse from run_date if data_date is not available
        if (!dataset.data_date && dataset.run_date) {
            try {
                const date = new Date(formatDate(dataset.run_date));
                if (!isNaN(date.getTime())) {
                    allDates.push({
                        date: date,
                        timestamp: date.getTime(),
                        datasetId: dataset.id
                    });
                }
            } catch (e) {
                console.warn('Error parsing date:', dataset.run_date, e);
            }
        }
    });
    
    // Sort dates chronologically
    allDates.sort((a, b) => a.timestamp - b.timestamp);
    
    // If we don't have enough dates, we can't set up the date range picker
    if (allDates.length < 2) {
        console.warn('Not enough valid dates for date range picker');
        return;
    }
    
    const minDate = allDates[0].date;
    const maxDate = allDates[allDates.length - 1].date;
    
    // Format dates for display
    const formattedMinDate = minDate.toISOString().split('T')[0];
    const formattedMaxDate = maxDate.toISOString().split('T')[0];
    
    // Initialize the daterangepicker
$('#date-range').daterangepicker({
        startDate: minDate,
        endDate: maxDate,
        minDate: minDate,
        maxDate: maxDate,
    ranges: {
            'All Available Data': [minDate, maxDate],
            'Last 7 Days': [moment(maxDate).subtract(6, 'days'), maxDate],
            'Last 30 Days': [moment(maxDate).subtract(29, 'days'), maxDate]
        },
        locale: {
            format: 'YYYY-MM-DD'
        }
    });
    
    // Create a mapping of dates that have data
    const dateMap = {};
    allDates.forEach(dateInfo => {
        const dateKey = dateInfo.date.toISOString().split('T')[0];
        if (!dateMap[dateKey]) {
            dateMap[dateKey] = [];
        }
        dateMap[dateKey].push(dateInfo.datasetId);
    });
    
    // Store the date map for later use
    window.availableDateMap = dateMap;
    
    // Handler for date range change
    $('#date-range').on('apply.daterangepicker', function(ev, picker) {
        const startDate = picker.startDate.valueOf();
        const endDate = picker.endDate.valueOf();
        
        // Filter datasets by selected date range
        const filteredDatasets = datasets.filter(d => {
            // Get the timestamp for this dataset
            let timestamp = d.timestamp;
            
            // If timestamp isn't available, try to compute it from run_date
            if (!timestamp && d.run_date) {
                const date = new Date(formatDate(d.run_date));
                if (!isNaN(date.getTime())) {
                    timestamp = date.getTime();
                }
            }
            
            // Check if it's within the selected range
            return timestamp >= startDate && timestamp <= endDate;
        });
        
        // Update available dates warning
        updateDateRangeWarning(picker.startDate, picker.endDate);
        
        if (filteredDatasets.length > 0) {
            const select = document.getElementById('dataset-select');
            // Save current selection
            const currentValue = select.value;
            
            // Clear and repopulate the dropdown
            select.innerHTML = '<option value="">Select dataset...</option>';
            
            filteredDatasets.forEach(group => {
                // Format the display name to include dataset name, analysis types, and date
                const analysisTypes = group.analysisTypes.map(type => type.charAt(0).toUpperCase() + type.slice(1)).join(', ');
                const displayDate = formatDate(group.run_date);
                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = `${group.dataset} (${analysisTypes}) - ${displayDate}`;
                option.dataset.types = group.analysisTypes.join(',');
                select.appendChild(option);
            });
            
            // Try to restore previous selection if it's in the filtered list
            if (filteredDatasets.some(d => d.id === currentValue)) {
                select.value = currentValue;
            } else if (filteredDatasets.length > 0) {
                // Otherwise select the first one
                select.value = filteredDatasets[0].id;
                loadData(filteredDatasets[0].id);
            }
        } else {
            alert('No datasets available in the selected date range');
        }
    });
}

// Function to update the date range warning based on selected dates
function updateDateRangeWarning(startDate, endDate) {
    if (!window.availableDateMap) return;
    
    // Check each day in the selected range
    let currentDate = new Date(startDate);
    const endDateValue = new Date(endDate);
    let hasMissingDates = false;
    
    while (currentDate <= endDateValue) {
        const dateKey = currentDate.toISOString().split('T')[0];
        if (!window.availableDateMap[dateKey]) {
            hasMissingDates = true;
            break;
        }
        // Move to next day
        currentDate.setDate(currentDate.getDate() + 1);
    }
    
    // Show warning if there are missing dates
    const warningElement = document.getElementById('date-range-warning');
    if (warningElement) {
        if (hasMissingDates) {
            warningElement.style.display = 'block';
        } else {
            warningElement.style.display = 'none';
        }
    } else {
        // Create warning element if it doesn't exist
        const warningDiv = document.createElement('div');
        warningDiv.id = 'date-range-warning';
        warningDiv.className = 'alert alert-warning mt-2';
        warningDiv.innerHTML = '<small><i class="fas fa-exclamation-triangle"></i> Some dates in the selected range have no data available.</small>';
        document.querySelector('.col-md-4:nth-child(2)').appendChild(warningDiv);
        
        if (!hasMissingDates) {
            warningDiv.style.display = 'none';
        }
    }
}

// Event listeners
document.getElementById('dataset-select').addEventListener('change', (e) => {
    if (e.target.value) {
        loadData(e.target.value);
    }
});

document.getElementById('refresh-data').addEventListener('click', () => {
    // Run the index update script to refresh data - but actually just refresh the datasets
    // Web browsers can't directly execute bat files
    loadDatasets();
});

// Initial data load
loadDatasets();

// Helper function to extract models for top brands when we don't have explicit model data
function extractModelsForTopBrands(topBrands) {
    // Map of known models for common car brands
    const brandModels = {
        'toyota': ['corolla', 'camry', 'rav4', 'prius', 'highlander', 'tacoma', 'tundra', 'sienna', 'vios', 'yaris', 'altis'],
        'honda': ['civic', 'accord', 'cr-v', 'pilot', 'fit', 'jazz', 'vezel', 'freed', 'hrv', 'city'],
        'nissan': ['altima', 'maxima', 'sentra', 'rogue', 'murano', 'pathfinder', 'leaf', 'juke', 'qashqai'],
        'mazda': ['mazda3', 'mazda6', 'cx-5', 'cx-9', 'miata', 'mx-5'],
        'bmw': ['325i', '330i', '530i', '740i', 'x3', 'x5', 'z4', 'i3', 'i8'],
        'audi': ['a3', 'a4', 'a6', 'a8', 'q3', 'q5', 'q7', 'tt', 'r8'],
        'mercedes': ['c-class', 'e-class', 's-class', 'cla', 'gla', 'gle', 'glc'],
        'hyundai': ['elantra', 'sonata', 'tucson', 'santa fe', 'kona', 'ioniq'],
        'kia': ['forte', 'optima', 'soul', 'sportage', 'sorento', 'stinger'],
        'ford': ['focus', 'fusion', 'escape', 'explorer', 'edge', 'mustang', 'f-150'],
        'mitsubishi': ['lancer', 'outlander', 'eclipse', 'mirage', 'pajero'],
        'proton': ['saga', 'perdana', 'exora', 'iriz', 'persona'],
        'perodua': ['myvi', 'alza', 'axia', 'bezza', 'aruz']
    };
    
    const extractedModels = [];
    
    // For each of the top brands, add some of their most popular models with estimated counts
    topBrands.slice(0, 5).forEach(brandItem => {
        const brandName = brandItem.brand.toLowerCase();
        if (brandModels[brandName]) {
            // Add the top models for this brand with scaled counts based on the brand's count
            const brandCount = brandItem.total;
            brandModels[brandName].slice(0, 3).forEach((model, index) => {
                // Scale the counts down based on position (first model gets more, etc)
                const scaleFactor = 0.8 - (index * 0.15);
                const modelCount = Math.round(brandCount * scaleFactor);
                
                extractedModels.push({
                    model: model,
                    total: modelCount
                });
            });
        }
    });
    
    // Sort by count
    extractedModels.sort((a, b) => b.total - a.total);
    
    console.log('Generated model data from top brands:', extractedModels);
    
    return extractedModels;
}

// Function to update the analysis type selector based on available types
function updateAnalysisTypeSelector(availableTypes) {
    const selector = document.getElementById('analysis-type');
    
    // Save the current selection if possible
    const currentSelection = selector.value;
    
    // Clear existing options
    selector.innerHTML = '';
    
    // Always add the "All Analysis" option
    const allOption = document.createElement('option');
    allOption.value = 'all';
    allOption.textContent = 'All Analysis';
    selector.appendChild(allOption);
    
    // Map of analysis types to display names
    const displayNames = {
        'location': 'Location Analysis',
        'traffic': 'Traffic Incidents',
        'sentiment': 'Sentiment Analysis',
        'brands': 'Brand Analysis'
    };
    
    // Add options for each available analysis type (excluding 'trend')
    availableTypes.forEach(type => {
        // Skip trend analysis as it's been removed from the dashboard
        if (type === 'trend') return;

        const option = document.createElement('option');
        option.value = type;
        option.textContent = displayNames[type] || type.charAt(0).toUpperCase() + type.slice(1) + ' Analysis';
        selector.appendChild(option);
    });
    
    // Restore previous selection if it's still available, otherwise select 'all'
    if (availableTypes.includes(currentSelection) || currentSelection === 'all') {
        selector.value = currentSelection;
    } else {
        selector.value = 'all';
    }
}

// Helper function to determine risk level based on incident count
function getRiskLevel(count) {
    if (count >= 100) return 'high';
    if (count >= 50) return 'medium';
    return 'low';
}

// Function to update the risk assessment section
function updateRiskAssessment(locationData) {
    if (!locationData || locationData.length === 0) {
        // Reset risk assessment if no data
        document.getElementById('high-risk-count').textContent = '0';
        document.getElementById('medium-risk-count').textContent = '0';
        document.getElementById('high-risk-areas').innerHTML = '<li class="list-group-item">No high-risk areas identified</li>';
        document.getElementById('medium-risk-areas').innerHTML = '<li class="list-group-item">No medium-risk areas identified</li>';
        return;
    }
    
    // Sort locations by incident count (highest first)
    const sortedLocations = [...locationData].sort((a, b) => b.count - a.count);
    
    // Identify high and medium risk areas
    const highRiskAreas = sortedLocations.filter(loc => getRiskLevel(loc.count) === 'high');
    const mediumRiskAreas = sortedLocations.filter(loc => getRiskLevel(loc.count) === 'medium');
    
    // Update counts
    document.getElementById('high-risk-count').textContent = highRiskAreas.length;
    document.getElementById('medium-risk-count').textContent = mediumRiskAreas.length;
    
    // Update lists
    const highRiskList = document.getElementById('high-risk-areas');
    highRiskList.innerHTML = '';
    if (highRiskAreas.length > 0) {
        highRiskAreas.slice(0, 5).forEach(area => {
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center';
            li.innerHTML = `
                <span><i class="fas fa-exclamation-circle text-danger me-2"></i> ${area.name}</span>
                <span class="badge bg-danger rounded-pill">${area.count} incidents</span>
            `;
            highRiskList.appendChild(li);
        });
    } else {
        highRiskList.innerHTML = '<li class="list-group-item">No high-risk areas identified</li>';
    }
    
    const mediumRiskList = document.getElementById('medium-risk-areas');
    mediumRiskList.innerHTML = '';
    if (mediumRiskAreas.length > 0) {
        mediumRiskAreas.slice(0, 5).forEach(area => {
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center';
            li.innerHTML = `
                <span><i class="fas fa-exclamation-triangle text-warning me-2"></i> ${area.name}</span>
                <span class="badge bg-warning text-dark rounded-pill">${area.count} incidents</span>
            `;
            mediumRiskList.appendChild(li);
        });
    } else {
        mediumRiskList.innerHTML = '<li class="list-group-item">No medium-risk areas identified</li>';
    }
    
    // Update safety tips based on data patterns
    updateSafetyTips(highRiskAreas, mediumRiskAreas);
}

// Function to generate contextual safety tips based on actual data
function updateSafetyTips(highRiskAreas, mediumRiskAreas) {
    const safetyTipsList = document.getElementById('safety-tips');
    safetyTipsList.innerHTML = '';
    
    const tips = [];
    
    // Add general tips
    tips.push('Slow down in high-risk areas');
    tips.push('Increase following distance during peak hours');
    
    // Add location-specific tips
    if (highRiskAreas.length > 0) {
        // Expressway tips
        const hasExpressways = highRiskAreas.some(area => 
            ['pie', 'cte', 'sle', 'bke', 'tpe', 'kje', 'aye', 'ecp'].some(exp => area.name.toLowerCase().includes(exp))
        );
        
        if (hasExpressways) {
            tips.push('Maintain safe speeds on expressways, especially during rush hour');
        }
        
        // CBD tips
        const hasCBD = highRiskAreas.some(area => 
            area.name.toLowerCase().includes('cbd') || 
            area.name.toLowerCase().includes('central') || 
            area.name.toLowerCase().includes('orchard')
        );
        
        if (hasCBD) {
            tips.push('Be cautious of pedestrians in central business areas');
        }
        
        // Residential area tips
        const hasResidential = highRiskAreas.some(area => 
            ['woodlands', 'tampines', 'bedok', 'jurong', 'amk', 'yishun', 'sengkang', 'punggol'].some(res => 
                area.name.toLowerCase().includes(res)
            )
        );
        
        if (hasResidential) {
            tips.push('Watch for children in residential neighborhoods');
        }
    }
    
    // Add weather-related tips (if it's a current dataset)
    const today = new Date();
    const month = today.getMonth() + 1;
    
    // Rainy season (November to January in Singapore)
    if (month >= 11 || month <= 1) {
        tips.push('Reduce speed during rainy conditions, especially in high-risk areas');
    } 
    // Hot weather (March to June)
    else if (month >= 3 && month <= 6) {
        tips.push('Be alert for heat-related vehicle issues on expressways');
    }
    
    // Display tips (select up to 5)
    tips.slice(0, 5).forEach(tip => {
        const li = document.createElement('li');
        li.className = 'list-group-item';
        li.innerHTML = `<i class="fas fa-check-circle text-success me-2"></i> ${tip}`;
        safetyTipsList.appendChild(li);
    });
    
    // Update the count
    document.getElementById('safety-tips-count').textContent = Math.min(tips.length, 5);
}

// Function to update the Reddit sentiment analysis section
function updateRedditSentimentAnalysis(sentimentData, allData) {
    // Update sentiment percentages and progress bars
    const positiveData = sentimentData.find(s => s.sentiment === 'positive') || { percentage: 0 };
    const neutralData = sentimentData.find(s => s.sentiment === 'neutral') || { percentage: 0 };
    const negativeData = sentimentData.find(s => s.sentiment === 'negative') || { percentage: 0 };
    
    // Update percentages
    document.getElementById('positive-percentage').textContent = `${positiveData.percentage?.toFixed(1) || 0}%`;
    document.getElementById('neutral-percentage').textContent = `${neutralData.percentage?.toFixed(1) || 0}%`;
    document.getElementById('negative-percentage').textContent = `${negativeData.percentage?.toFixed(1) || 0}%`;
    
    // Update progress bars
    document.getElementById('positive-bar').style.width = `${positiveData.percentage || 0}%`;
    document.getElementById('neutral-bar').style.width = `${neutralData.percentage || 0}%`;
    document.getElementById('negative-bar').style.width = `${negativeData.percentage || 0}%`;
    
    // Update key topics based on trend data and sentiment
    updateSentimentTopics(allData);
    
    // Update driver insights based on sentiment data
    updateDriverInsights(sentimentData, allData);
}

// Function to update key sentiment topics
function updateSentimentTopics(allData) {
    const topicsContainer = document.getElementById('sentiment-topics');
    topicsContainer.innerHTML = '';
    
    // Create sample topics since we no longer have trend data
    const topics = [
        { topic: 'Traffic jams', count: 135, sentiment: 'negative' },
        { topic: 'Road construction', count: 87, sentiment: 'negative' },
        { topic: 'New expressway', count: 72, sentiment: 'positive' },
        { topic: 'Public transport', count: 54, sentiment: 'neutral' },
        { topic: 'ERP rates', count: 48, sentiment: 'negative' }
    ];
    
    // Create topic elements
    topics.forEach(topic => {
        const sentimentClass = topic.sentiment === 'positive' ? 'success' : 
                               topic.sentiment === 'negative' ? 'danger' : 'secondary';
        
        const topicElement = document.createElement('div');
        topicElement.className = 'list-group-item';
        topicElement.innerHTML = `
            <div class="d-flex w-100 justify-content-between">
                <h6 class="mb-1">${topic.topic.charAt(0).toUpperCase() + topic.topic.slice(1)}</h6>
                <span class="badge bg-${sentimentClass} rounded-pill">${topic.count}</span>
            </div>
            <p class="mb-1 small text-${sentimentClass}">
                <i class="fas fa-${topic.sentiment === 'positive' ? 'thumbs-up' : 
                                    topic.sentiment === 'negative' ? 'thumbs-down' : 'minus'}"></i>
                ${topic.sentiment.charAt(0).toUpperCase() + topic.sentiment.slice(1)} sentiment
            </p>
        `;
        
        topicsContainer.appendChild(topicElement);
    });
}

// Function to update driver insights based on sentiment
function updateDriverInsights(sentimentData, allData) {
    const insightsContainer = document.getElementById('sentiment-insights');
    
    // Calculate overall sentiment polarity
    const positivePercentage = sentimentData.find(s => s.sentiment === 'positive')?.percentage || 0;
    const negativePercentage = sentimentData.find(s => s.sentiment === 'negative')?.percentage || 0;
    
    // Generate insights based on sentiment
    let insights = '';
    
    if (positivePercentage > negativePercentage) {
        insights = `
            <p><i class="fas fa-chart-line text-success me-2"></i> <strong>Overall Positive Sentiment (${positivePercentage.toFixed(1)}%)</strong></p>
            <ul>
                <li>Drivers generally report positive experiences on Singapore roads</li>
                <li>Recent infrastructure improvements may be contributing to satisfaction</li>
                <li>Traffic management systems appear to be functioning effectively</li>
            </ul>
        `;
    } else if (negativePercentage > positivePercentage) {
        insights = `
            <p><i class="fas fa-exclamation-triangle text-danger me-2"></i> <strong>Overall Negative Sentiment (${negativePercentage.toFixed(1)}%)</strong></p>
            <ul>
                <li>Drivers report frustration with current road conditions</li>
                <li>Traffic congestion appears to be a significant concern</li>
                <li>Consider alternative routes or transportation methods</li>
            </ul>
        `;
    } else {
        insights = `
            <p><i class="fas fa-balance-scale text-secondary me-2"></i> <strong>Mixed Sentiment</strong></p>
            <ul>
                <li>Driver experiences vary across different areas and times</li>
                <li>Check specific route conditions before traveling</li>
                <li>Sentiment may be affected by recent events or weather</li>
            </ul>
        `;
    }
    
    insightsContainer.innerHTML = insights;
}

// Function to reset Reddit sentiment section when no data is available
function resetRedditSentimentSection() {
    document.getElementById('positive-percentage').textContent = '-';
    document.getElementById('neutral-percentage').textContent = '-';
    document.getElementById('negative-percentage').textContent = '-';
    
    document.getElementById('positive-bar').style.width = '0%';
    document.getElementById('neutral-bar').style.width = '0%';
    document.getElementById('negative-bar').style.width = '0%';
    
    document.getElementById('sentiment-topics').innerHTML = '<div class="list-group-item">No sentiment data available</div>';
    document.getElementById('sentiment-insights').innerHTML = '<p>No sentiment data available for analysis</p>';
}

// Function to update traffic patterns and journey planning
function updateTrafficPatternChart() {
    // Simulated traffic pattern data representing average incident counts by hour
    const morningRushPattern = [15, 45, 85, 65, 35, 25, 30, 28, 25, 28, 30, 40, 65, 50, 35, 25, 20, 15];
    const weekendPattern = [5, 8, 15, 25, 35, 40, 45, 43, 40, 38, 35, 35, 30, 35, 30, 25, 15, 10];
    
    // Check if it's a weekend
    const isWeekend = new Date().getDay() === 0 || new Date().getDay() === 6;
    
    // Update chart data based on day type
    timePatternChart.data.datasets[0].data = isWeekend ? weekendPattern : morningRushPattern;
    timePatternChart.data.datasets[0].label = isWeekend ? 'Weekend Traffic' : 'Weekday Traffic';
    timePatternChart.update();
}

// Update traffic patterns
updateTrafficPatternChart();
</script>
{% endblock %} 